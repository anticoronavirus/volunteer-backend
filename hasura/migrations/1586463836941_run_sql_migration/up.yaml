- args:
    cascade: false
    read_only: false
    sql: "CREATE OR REPLACE FUNCTION public.shift_selector(_hospital_id uuid DEFAULT
      NULL::uuid)\n RETURNS SETOF vshift\n LANGUAGE sql\n STABLE\nAS $function$ \nSELECT
      (days.date)::date AS date,\n    period.start,\n    period.\"end\",\n    count(DISTINCT
      period.hospital_id)::integer AS hospitalscount,\n    sum(period.vdemand)::integer
      AS demand,\n    (((sum(period.vdemand))::numeric - COALESCE(sum(vs_stat.subs),
      (0)::numeric)))::integer AS placesavailable,\n    gen_random_uuid() as uid\n
      \   FROM (((select *, case when shortname = 'Коммунарка' then 0 else demand
      end as vdemand from period inner join hospital on hospital.uid = hospital_id)
      period\n     LEFT JOIN generate_series((CURRENT_DATE)::timestamp without time
      zone, (CURRENT_DATE + '14 days'::interval), '1 day'::interval) days(date) ON
      (true))\n     LEFT JOIN ( SELECT volunteer_shift.date,\n            volunteer_shift.start,\n
      \           volunteer_shift.\"end\",\n            count(volunteer_shift.uid)
      AS subs,\n            hospital_id\n           FROM volunteer_shift\n          GROUP
      BY volunteer_shift.date, volunteer_shift.start, volunteer_shift.\"end\", volunteer_shift.hospital_id)
      vs_stat ON (((vs_stat.date = (days.date)::date) AND (vs_stat.start = period.start)
      AND (vs_stat.\"end\" = period.\"end\") AND vs_stat.hospital_id = period.hospital_id)))\n
      \ WHERE CASE WHEN _hospital_id IS NULL THEN TRUE ELSE period.hospital_id = _hospital_id
      END \n  GROUP BY ((days.date)::date), period.start, period.\"end\"\n  ORDER
      BY date, period.start;\n  $function$;"
  type: run_sql
